#+begin_export latex
\section{Introduction}
The program \ty{makeFurDb} takes as input a directory of target files
and a directory of neighbor files. From these two directories it
constructs a third, the \ty{fur} database. This ``database'' is then
analyzed with \ty{fur} to discover regions common to the targets that
are absent from the neighbors. The strategy for finding these regions
is described in the Introduction and summarized there in
steps~(\ref{eq:fur1}) to (\ref{eq:fur3}). To enable \ty{fur} to carry
out these steps, \ty{makeFurDb} fills the database with six elements,
\begin{enumerate}
\item a file containing the program version, \ty{v.txt}
\item a file containing the target sequence on which the search for
  diagnostic markers is centered, the target representative,
  \ty{r.fasta}
\item a file containing the enhanced suffix array, ESA, of the target
  representative, \ty{r.idx}
\item a directory containing all targets minus the target
  representative, \ty{t/}
\item a Blast database of the neighbors, \ty{n}
\item a file containing the combined length of the neighbor sequences
  and their GC content, \ty{n.txt}
\end{enumerate}
The implementation of \ty{makeFurDb} is structured along the
construction of these six parts of the database.

\section{Implementation}
Our outline of \ty{makeFurDb} contains hooks for imports, functions,
and the logic of the main function.  \bpr{makeFurDb}{pr:mfd}
#+end_export
#+begin_src go <<makeFurDb.go>>=
  package main

  import (
	  //<<Imports, Pr. \ref{pr:mfd}>>
  )
  //<<Functions, Pr. \ref{pr:mfd}>>
  func main() {
	  //<<Main function, Pr. \ref{pr:mfd}>>
  }
#+end_src
#+begin_export latex
\epr In the main function we prepare the error handling, declare the
options, set the usage, parse the options, and construct the \ty{fur}
database.
#+end_export
#+begin_src go <<Main function, Pr. \ref{pr:mfd}>>=
  //<<Prepare error handling, Pr. \ref{pr:mfd}>>
  //<<Declare options, Pr. \ref{pr:mfd}>>
  //<<Set usage, Pr. \ref{pr:mfd}>>
  //<<Parse options, Pr. \ref{pr:mfd}>>
  //<<Construct \ty{fur} database, Pr. \ref{pr:mfd}>>
#+end_src
#+begin_export latex
We prepare error handling by calling the utility function
\ty{PrepareErrorMessages}.
#+end_export
#+begin_src go <<Prepare error handling, Pr. \ref{pr:mfd}>>=
  util.PrepareErrorMessages("makeFurDb")
#+end_src
#+begin_src latex
  We declare options for printing the version, for picking the
  directories holding the targets, the neighbors, and the database, for
  picking the target representative, and for allowing an existing
  database to be overwritten.
#+end_src
#+begin_src go <<Declare options, Pr. \ref{pr:mfd}>>=
  optV := flag.Bool("v", false, "version")
  optT := flag.String("t", "", "target directory")
  optN := flag.String("n", "", "neighbor directory")
  optD := flag.String("d", "", "database directory")
  optR := flag.String("r", "", "target representative " +
	  "(default shortest)")
  optO := flag.Bool("o", false, "overwrite existing database")
#+end_src
#+begin_src latex
  We import \ty{flag}.
#+end_src
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "flag"
#+end_src
#+begin_export latex
The coordinates returned by a \ty{fur} analysis are with respect to
the target representative stored in \ty{r.fasta}. However, they will
usually be read as being with respect to the original target
representative submitted by the user. By default, \ty{makeFurDb} sets
nucleotides to upper case and then removes any character that isn't
\ty{A}, \ty{C}, \ty{G}, or \ty{T}. In most cases these non-canonical
nucleotides are stretches of \ty{N}s, which cannot be used in primer
design, the original purpose of Fur. 

The disadvantage of removing non-canonical nucleotides is that this
can lead to differences between the coordinates in \ty{r.fasta} and
its original. Annotations like genes are given with respect to this
original, so we also add an option for keeping non-canonical
nucleotides.
#+end_export
#+begin_src go <<Declare options, Pr. \ref{pr:mfd}>>=
  optK := flag.Bool("k", false, "keep non-canonical nucleotides")
#+end_src
#+begin_export latex
The usage consists of three parts, the actual usage message, an
explanation of the purpose of \ty{makeFurDb}, and an example command.
#+end_export
#+begin_src go <<Set usage, Pr. \ref{pr:mfd}>>=
  u := "makeFurDb [option]... -t <targetDir> " +
	  "-n <neighborDir> -d <db>"
  p := "Construct fur database."
  e := "makeFurDb -t targets/ -n neighbors/ -d fur.db"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
We parse the options and respond to the version option, \ty{-v}, and
the three directory options, \ty{-t}, \ty{-n}, \ty{-d}.
#+end_export
#+begin_src go <<Parse options, Pr. \ref{pr:mfd}>>=
  flag.Parse()
  //<<Respond to \ty{-v}, Pr. \ref{pr:mfd}>>
  //<<Respond to \ty{-t}, Pr. \ref{pr:mfd}>>
  //<<Respond to \ty{-n}, Pr. \ref{pr:mfd}>>
  //<<Respond to \ty{-d}, Pr. \ref{pr:mfd}>>
#+end_src
#+begin_export latex
If the user requested the version, we call the utility function
\ty{PrintInfo} with the program name.
#+end_export
#+begin_src go <<Respond to \ty{-v}, Pr. \ref{pr:mfd}>>=
  if *optV {
	  util.PrintInfo("makeFurDb")
  }
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "github.com/evolbioinf/fur/util"
#+end_src
#+begin_export latex
If the user didn't set a targets directory, we exit with a friendly
message.
#+end_export
#+begin_src go <<Respond to \ty{-t}, Pr. \ref{pr:mfd}>>=
  if *optT == "" {
	  m := "please provide a directory " +
		  "of target sequences"
	  fmt.Fprintf(os.Stderr, "%s\n", m)
	  os.Exit(1)
  }
#+end_src
#+begin_export latex
We import \ty{fmt} and \ty{os}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "fmt"
  "os"
#+end_src
#+begin_export latex
We do the same if the user didn't set a neighbors directory.
#+end_export
#+begin_src go <<Respond to \ty{-n}, Pr. \ref{pr:mfd}>>=
  if *optN == "" {
	  m := "please provide a directory " +
		  "of neighbor sequences"
	  fmt.Fprintf(os.Stderr, "%s\n", m)
	  os.Exit(1)
  }
#+end_src
#+begin_export latex
The database directory is the last directory the user needs to set. If
the user failed to do so, we abort with a friendly message. If, on the
other hand, the user named an existing database, we deal with it. At
the end we construct the empty database directory that we fill in the
following sections.
#+end_export
#+begin_src go <<Respond to \ty{-d}, Pr. \ref{pr:mfd}>>=
  if *optD == "" {
	  m := "please provide a database name"
	  fmt.Fprintf(os.Stderr, "%s\n", m)
	  os.Exit(1)
  } else {
	  _, err := os.Stat(*optD)
	  if err == nil {
		  //<<Deal with existing database, Pr. \ref{pr:mfd}>>
	  }
	  err = os.Mkdir(*optD, 0750)
	  util.Check(err)
  }

#+end_src
#+begin_export latex
If the user allowed the database to be overwritten, we remove
it. Otherwise, we bail with a friendly message.
#+end_export
#+begin_src go <<Deal with existing database, Pr. \ref{pr:mfd}>>=
  if *optO {
	  err := os.RemoveAll(*optD)
	  util.Check(err)
  } else {
	  m := fmt.Sprintf("database %s already exists", *optD)
	  fmt.Fprintf(os.Stderr, "%s\n", m)
	  os.Exit(1)
  }
#+end_src
#+begin_export latex
To construct the \ty{fur} database, we read the names of the targets
and neighbors and make sure the two lists don't overlap. This is best
done by storing the names of the targets and neighbors in
maps. However, map keys are accessed randomly. To impose order on
them, we sort the names before making sure they don't overlap. Then we
construct the six elements of the \ty{fur} database to store the
version, the target representative, $r$, its ESA, the other targets,
the blast database of neighbors, and the statistics of the neighbor
sequences. These statistics are later used by \ty{fur} to calculate
the null distribution of match lengths.
#+end_export
#+begin_src go <<Construct \ty{fur} database, Pr. \ref{pr:mfd}>>=
  //<<Read names of targets and neighbors, Pr. \ref{pr:mfd}>>
  //<<Sort names of targets and neighbors, Pr. \ref{pr:mfd}>>
  //<<Do targets and neighbors overlap? Pr. \ref{pr:mfd}>>
  //<<Write version to \ty{v.txt}, Pr. \ref{pr:mfd}>>
  //<<Write $r$ to \ty{r.fasta}, Pr. \ref{pr:mfd}>>
  //<<Write ESA of $r$ to \ty{r.idx}, Pr. \ref{pr:mfd}>>
  //<<Write the other targets to \ty{t/}, Pr. \ref{pr:mfd}>>
  //<<Write Blast database of neighbors to \ty{n}, Pr. \ref{pr:mfd}>>
  //<<Write statistics of neighbors to \ty{n.txt}, Pr. \ref{pr:mfd}>>
#+end_src
#+begin_export latex
We delegate reading the names of the targets and neighbors to the
function \ty{readDir}. If either of these directories is empty, we
bail with a friendly message.
#+end_export
#+begin_src go <<Read names of targets and neighbors, Pr. \ref{pr:mfd}>>=
  targets := readDir(*optT)
  if len(targets) == 0 {
	  fmt.Fprintf(os.Stderr, "%s is empty\n", *optT)
	  os.Exit(1)
  }
  neighbors := readDir(*optN)
  if len(neighbors) == 0 {
	  fmt.Fprintf(os.Stderr, "%s is empty\n", *optN)
	  os.Exit(1)
  }
#+end_src
#+begin_export latex
The function \ty{readDir} takes as input the name of a directory and
returns a map of the names of the sequence files contained in the
directory. We check each directory entry before storing its name.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:mfd}>>=
  func readDir(dir string) map[string]bool {
	  dirEntries, err := os.ReadDir(dir)
	  util.Check(err)
	  names := make(map[string]bool)
	  for _, dirEntry := range dirEntries {
		  //<<Check directory entry, Pr. \ref{pr:mfd}>>
		  names[dirEntry.Name()] = true
	  }
	  return names
  }
#+end_src
#+begin_export latex
A directory entry should be a file rather than a subdirectory. Given
that it is indeed a file, it should also be a nucleotide FASTA file.
#+end_export
#+begin_src go <<Check directory entry, Pr. \ref{pr:mfd}>>=
  //<<Is the directory entry a file? Pr. \ref{pr:mfd}>>
  //<<Is the directory entry a nucleotide file? Pr. \ref{pr:mfd}>>
#+end_src
#+begin_export latex
If the directory entry is a subdirectory, we warn the user and skip
it.
#+end_export
#+begin_src go <<Is the directory entry a file? Pr. \ref{pr:mfd}>>=
  if dirEntry.IsDir() {
	  p := dir + "/" + dirEntry.Name()
	  fmt.Fprintf(os.Stderr,
		  "skipping subdirectory %s\n", p)
	  continue
  }
#+end_src
#+begin_export latex
There are five filename extensions that denote nucleotide FASTA files
listed on
Wikipedia\footnote{\ty{https://en.wikipedia.org/wiki/FASTA\_format}},
\ty{.fasta}, \ty{.fna}, \ty{.ffn}, \ty{.frn}, and \ty{.fa}. If the
file has a different extension or none, we skip it and send a warning.
#+end_export
#+begin_src go <<Is the directory entry a nucleotide file? Pr. \ref{pr:mfd}>>=
  ext := filepath.Ext(dirEntry.Name())
  if ext != ".fasta" && ext != ".fna" && ext != ".ffn" &&
	  ext != ".frn" && ext != ".fa" {
	  m := "%s doesn't have the extension of " +
		  "a nucleotide FASTA file; skipping it\n"
	  p := dir + "/" + dirEntry.Name()
	  fmt.Fprintf(os.Stderr, m, p)
	  continue
  }
#+end_src
#+begin_export latex
We import \ty{filepath}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "path/filepath"
#+end_src
#+begin_export latex
We store the names of the neighbors and targets in slices and sort
them.
#+end_export
#+begin_src go <<Sort names of targets and neighbors, Pr. \ref{pr:mfd}>>=
  var targetNames, neighborNames []string
  for target := range targets {
	  targetNames = append(targetNames, target)
  }
  sort.Strings(targetNames)
  for neighbor := range neighbors {
	  neighborNames = append(neighborNames, neighbor)
  }
  sort.Strings(neighborNames)
#+end_src
#+begin_export latex
We import \ty{sort}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "sort"
#+end_src
#+begin_export latex
A common error when searching for markers is to include a sequence
file in both the target and the neighbor set. To guard against this,
we search for pairs of repeated file names and bail with message if we
find one.
#+end_export
#+begin_src go <<Do targets and neighbors overlap? Pr. \ref{pr:mfd}>>=
  for _, target := range targetNames {
	  if neighbors[target] {
		  m := "found %s/%s and %s/%s; please " +
			  "make sure the targets and " +
			  "neighbors don't overlap"
		  fmt.Fprintf(os.Stderr, m, *optT,
			  target, *optN, target)
		  os.Exit(1)
	  }
  }
#+end_src
#+begin_export latex
\subsection{Version File, \ty{v.txt}}
To construct the version file, we open \ty{v.txt} inside the database,
write the version to it, and close it again.
#+end_export
#+begin_src go <<Write version to \ty{v.txt}, Pr. \ref{pr:mfd}>>=
  vf := *optD + "/v.txt"
  f, err := os.Create(vf)
  util.Check(err)
  fmt.Fprintf(f, "%s\n", util.Version())
  f.Close()
#+end_src
#+begin_export latex
\subsection{Target Representative, \ty{r.fasta}}
If the user didn't set a target representative, we need to pick
one. In any case, we report which target is used as
representative. Then we copy the target representative to \ty{r.fasta}
inside the database and close the files again.
#+end_export
#+begin_src go <<Write $r$ to \ty{r.fasta}, Pr. \ref{pr:mfd}>>=
  if *optR == "" {
	  //<<Pick target representative, Pr. \ref{pr:mfd}>>
  }
  fmt.Fprintf(os.Stderr, "using %s as target representative\n",
	  (*optR))
  source := *optT + "/" + *optR
  dest := *optD + "/r.fasta"
  //<<Open source and destination files, Pr. \ref{pr:mfd}>>
  //<<Copy source to destination, Pr. \ref{pr:mfd}>>
  //<<Close source and destination files, Pr. \ref{pr:mfd}>>
#+end_src
#+begin_export latex
By default, the target representative is the shortest target
sequence. To pick it, we iterate over the target files, calculate
their lengths, and store the name of the shortest target found so far
and its length. At the end we store the name of the overall shortest
target.
#+end_export
#+begin_src go <<Pick target representative, Pr. \ref{pr:mfd}>>=
  minTar := ""
  minLen := math.MaxInt
  for target, _ := range targets {
	  l := 0
	  //<<Calculate length of target sequence, Pr. \ref{pr:mfd}>>
	  if l < minLen {
		  minTar = target
		  minLen = l
	  }
  }
  (*optR) = minTar
#+end_src
#+begin_export latex
We import \ty{math}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "math"
#+end_src
#+begin_export latex
We iterate over the entries in the current target file and sum their
lengths.
#+end_export
#+begin_src go <<Calculate length of target sequence, Pr. \ref{pr:mfd}>>=
  p := *optT + "/" + target
  f, err := os.Open(p)
  util.Check(err)
  sc := fasta.NewScanner(f)
  for sc.ScanSequence() {
	  l += len(sc.Sequence().Data())
  }
#+end_src
#+begin_export latex
We import \ty{fasta}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "github.com/evolbioinf/fasta"
#+end_src
#+begin_export latex
We open the source file for reading and create the destination file
for writing.
#+end_export
#+begin_src go <<Open source and destination files, Pr. \ref{pr:mfd}>>=
  r, err := os.Open(source)
  util.Check(err)
  w, err := os.Create(dest)
  util.Check(err)
#+end_src
#+begin_export latex
We scan the sequences of the target representative. Each sequence is
converted to upper case, purged of characters other than the four
canonical nucleotides, \ty{A}, \ty{C}, \ty{G}, or \ty{T} unless the
user opted to keep them, and the header is reduced to the first token,
usually the accession. Then the sequence is added to the destination
file.
#+end_export
#+begin_src go <<Copy source to destination, Pr. \ref{pr:mfd}>>=
  sc := fasta.NewScanner(r)
  for sc.ScanSequence() {
	  seq := sc.Sequence()
	  d := bytes.ToUpper(seq.Data())
	  if !*optK {
		  //<<Remove non-canonical residues, Pr. \ref{pr:mfd}>>
	  }
	  header := strings.Fields(seq.Header())[0]
	  seq = fasta.NewSequence(header, d)
	  fmt.Fprintf(w, "%s\n", seq)
  }
#+end_src
#+begin_export latex
We import \ty{bytes} and \ty{strings}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "bytes"
  "strings"
#+end_src
#+begin_export latex
We close the source and destination files again.
#+end_export
#+begin_src go <<Close source and destination files, Pr. \ref{pr:mfd}>>=
  r.Close()
  w.Close()
#+end_src
#+begin_export latex
We remove the non-canonical bases using reslicing.
#+end_export
#+begin_src go <<Remove non-canonical residues, Pr. \ref{pr:mfd}>>=
  i := 0
  for _, c := range d {
	  if c == 'A' || c == 'C' || c == 'G' || c == 'T' {
		  d[i] = c
		  i++
	  }
  }
  d = d[:i]
#+end_src
#+begin_export latex
\subsection{Index of the Target Representative, \ty{r.idx}}
The ESA of $r$ functions later on as the index into the target
representative. We calculate this ESA and write it to the file
\ty{r.idx}.
#+end_export
#+begin_src go <<Write ESA of $r$ to \ty{r.idx}, Pr. \ref{pr:mfd}>>=
  //<<Calculate ESA of $r$, Pr. \ref{pr:mfd}>>
  //<<Write ESA to \ty{r.idx}, Pr. \ref{pr:mfd}>>
#+end_src
#+begin_export latex
We concatenate the sequences of the target rep and calculate their
ESA.
#+end_export
#+begin_src go <<Calculate ESA of $r$, Pr. \ref{pr:mfd}>>=
  var d []byte
  f, err = os.Open(*optD + "/r.fasta")
  util.Check(err)
  defer f.Close()
  sc = fasta.NewScanner(f)
  for sc.ScanSequence() {
	  s := sc.Sequence().Data()
	  d = append(d, s...)
  }
  es := esa.MakeEsa(d)
#+end_src
#+begin_export latex
We import \ty{esa}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "github.com/evolbioinf/esa"
#+end_src
#+begin_export latex
To maximize efficiency, we encode the ESA as a gob before writing it
to file.
#+end_export
#+begin_src go <<Write ESA to \ty{r.idx}, Pr. \ref{pr:mfd}>>=
  var buf bytes.Buffer
  enc := gob.NewEncoder(&buf)
  err = enc.Encode(es)
  util.Check(err)
  f, err = os.Create(*optD + "/r.idx")
  util.Check(err)
  defer f.Close()
  writer := bufio.NewWriter(f)
  writer.Write(buf.Bytes())
  err = writer.Flush()
  util.Check(err)
#+end_src
#+begin_export latex
We import \ty{gob} and \ty{bufio}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "encoding/gob"
  "bufio"
#+end_src
#+begin_export latex
\subsection{Target Directory, \ty{t/}}
We copy the targets minus the representative to the directory \ty{t}
inside the database.
#+end_export
#+begin_src go <<Write the other targets to \ty{t/}, Pr. \ref{pr:mfd}>>=
  p = *optD + "/t/"
  err = os.Mkdir(p, 0750)
  util.Check(err)
  for target, _ := range targets {
	  if target == *optR { continue }
	  source := *optT + "/" + target
	  dest := *optD + "/t/" + target
	  sd, err := os.ReadFile(source)
	  util.Check(err)
	  err = os.WriteFile(dest, sd, 0666)
  }
#+end_src
#+begin_export latex
\subsection{Blast Database of Neighbors, \ty{n}}
We come to the last element of the \ty{fur} database, the Blast
database of the neighbors. To construct this, we run the external
program \ty{makeblastdb} and pipe the neighbor sequences to it. At
this point we visit every neighbor sequence. So we take the
opportunity to also count the total number of nucleotides they
contain, $l$, and the number of \ty{C}s and \ty{G}s, $g$. These values
are later used in \ty{fur} to calculate the null distribution of match
lengths.
#+end_export
#+begin_src go <<Write Blast database of neighbors to \ty{n}, Pr. \ref{pr:mfd}>>=
  fmt.Fprintf(os.Stderr, "making Blast database\n")
  cmd := exec.Command("makeblastdb", "-dbtype", "nucl",
	  "-out", *optD + "/n", "-title", "t")
  stdin, err := cmd.StdinPipe()
  util.Check(err)
  var l, g int
  go func() {
	  defer stdin.Close()
	  //<<Pipe neighbors to \ty{makeblastdb}, Pr. \ref{pr:mfd}>>
  }()
  _, err = cmd.Output()
  util.Check(err)
#+end_src
#+begin_export latex
We import \ty{exec}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:mfd}>>=
  "os/exec"
#+end_src
#+begin_export latex
We iterate over the sequences in each neighbor file and print each
sequence to the destination file. We also count the total number of
nucleotides, $l$, and the combined number of \ty{G} and \ty{C}, $g$.
#+end_export
#+begin_src go <<Pipe neighbors to \ty{makeblastdb}, Pr. \ref{pr:mfd}>>=
  for neighbor, _ := range neighbors {
	  p := *optN + "/" + neighbor
	  r, err := os.Open(p)
	  util.Check(err)
	  sc := fasta.NewScanner(r)
	  for sc.ScanSequence() {
		  seq := sc.Sequence()
		  //<<Update $l$ and $g$, Pr. \ref{pr:mfd})>>
		  fmt.Fprintf(stdin, "%s\n", seq)
	  }
  }
#+end_src
#+begin_export latex
We scan across the sequence data to count the residues.
#+end_export
#+begin_src go <<Update $l$ and $g$, Pr. \ref{pr:mfd})>>=
  d := bytes.ToUpper(seq.Data())
  for _, c := range d {
	  if c == 'A' || c == 'C' || c == 'G' || c == 'T' {
		  l++
		  if c == 'C' || c == 'G' {
			  g++
		  }
	  }
  }
#+end_src
#+begin_export latex
\subsection{Neighbor Statistics, \ty{n.txt}}
We write the number of nucleotides and the GC content to file.
#+end_export
#+begin_src go <<Write statistics of neighbors to \ty{n.txt}, Pr. \ref{pr:mfd}>>=
  w, err = os.Create(*optD + "/n.txt")
  util.Check(err)
  gc := float64(g) / float64(l)
  fmt.Fprintf(w, "length: %d\nGC-content: %f\n", l, gc)
  w.Close()
#+end_src
#+begin_export latex
We are done with \ty{makeFurDb}, time to test it.
\section{Testing}
Our program to test \ty{makeFurDb} has hooks for imports and the
testing logic.
#+end_export
#+begin_src go <<makeFurDb_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Pr. \ref{pr:mfd}>>
  )

  func TestMakeFurDb(t *testing.T) {
	  //<<Testing, Pr. \ref{pr:mfd}>>
  }
#+end_src
#+begin_export latex
We construct a set of tests and iterate over them.
#+end_export
#+begin_src go <<Testing, Pr. \ref{pr:mfd}>>=
  var tests []*exec.Cmd
  //<<Construct tests, Pr. \ref{pr:mfd}>>
  for i, test := range tests {
	  //<<Run test, Pr. \ref{pr:mfd}>>
  }
#+end_src
#+begin_export latex
We import \ty{exec}.
#+end_export
#+begin_src go <<Testing imports, Pr. \ref{pr:mfd}>>=
  "os/exec"
#+end_src
#+begin_export latex
Our first test is a run with default options, where we only set the
targets, neighbors and the database. We also allow the database to be
overwritten.
#+end_export
#+begin_src go <<Construct tests, Pr. \ref{pr:mfd}>>=
  p := "./makeFurDb"
  a := "targets"
  n := "neighbors"
  d := "test.db"
  test := exec.Command(p, "-t", a, "-n", n, "-d", d, "-o")
  tests = append(tests, test)
#+end_src
#+begin_export latex
In our second test we also pick \ty{t2.fasta} as the target
representative.
#+end_export
#+begin_src go <<Construct tests, Pr. \ref{pr:mfd}>>=
  r := "t2.fasta"
  test = exec.Command(p, "-t", a, "-n", n, "-d", d, "-o",
	  "-r", r)
  tests = append(tests, test)
#+end_src
#+begin_export latex
We run a test and compare the result we get, that is, the index file
\ty{r.idx}, with the results we want, which are stored in the files
\ty{r1.idx} and \ty{r2.idx}.
#+end_export
#+begin_src go <<Run test, Pr. \ref{pr:mfd}>>=
  _, err := test.Output()
  if err != nil { t.Error(err) }
  get, err := os.ReadFile(d + "/r.idx")
  if err != nil { t.Error(err) }
  f := "r" + strconv.Itoa(i+1) + ".idx"
  want, err := os.ReadFile(f)
  if err != nil { t.Error(err) }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_export latex
We import \ty{os}, \ty{strconv}, and \ty{bytes}.
#+end_export
#+begin_src go <<Testing imports, Pr. \ref{pr:mfd}>>=
  "os"
  "strconv"
  "bytes"
#+end_src
