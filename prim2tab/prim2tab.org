#+begin_src latex
  \section{Introduction}
  The primers generated by \ty{primer3}~\cite{unt12:pri} often need to
  be ordered to allow easy extraction of those with the lowest
  penalty. However, the output of \ty{primer3} has the key/value
  structure shown in Figure~\ref{fig:prim}, which makes direct sorting
  difficult.
  \begin{figure}
    \begin{center}
      \fbox{
	\begin{minipage}{8.3cm}
	  \verbatiminput{../prim2tab/sample.txt}
	\end{minipage}
      }
    \end{center}
    \caption{Sample output from the primer design program
      \ty{primer3}~\cite{unt12:pri}.}\label{fig:prim}
  \end{figure}

  The program \ty{prim2tab} takes the output of \ty{primer3} as input
  and prints a table of primers where each row consists of the following
  four columns:
  \begin{enumerate}
  \item penalty of primer pair
  \item sequence of left primer
  \item sequence of right primer
  \item sequence of internal primer
  \end{enumerate}
  As shown in Figure~\ref{fig:prim}, this is also the order in which
  these items are reported by \ty{primer3}.

  Here is some sample output from \ty{prim2tab}, which can now be
  ordered by score by piping it through \ty{sort -n}.
  \footnotesize
  \begin{verbatim}
  # Penalty  Forward                 Reverse                Internal
  0.991909   AGGCGATATCTTCAACGGTA    AAAACTGTTTGCCGAGGAAG   GGGAAGGGTAGATTCATG
  0.991909   TAGGCGATATCTTCAACGGT    AAAACTGTTTGCCGAGGAAG   GGGAAGGGTAGATTCATG
  0.998004   GTAGGCGATATCTTCAACGG    AAAACTGTTTGCCGAGGAAG   GGGAAGGGTAGATTCATG
  0.998004   GGTAGGCGATATCTTCAACG    AAAACTGTTTGCCGAGGAAG   GGGAAGGGTAGATTCATG
  \end{verbatim}
  \normalsize
  \section{Implementation}
  The program \ty{prim2tab} has hooks for imports, variables, functions,
  and the logic of the main function.
  \bpr{prim2tab}{pr:p2t}
#+end_src
#+begin_src go <<prim2tab.go>>=
  package main

  import (
	  //<<Imports, P. \ref{pr:p2t}>>
  )
  //<<Variables, P. \ref{pr:p2t}>>
  //<<Functions, P. \ref{pr:p2t}>>
  func main() {
	  //<<Main function, P. \ref{pr:p2t}>>
  }
#+end_src
#+begin_src latex
  \epr In the main function we first prepare the error messages. Then we
  set the usage, declare and parse the options, and parse the input
  files.
#+end_src
#+begin_src go <<Main function, P. \ref{pr:p2t}>>=
  util.PrepareErrorMessages("prim2tab")
  //<<Set usage, P. \ref{pr:p2t}>>
  //<<Declare options, P. \ref{pr:p2t}>>
  //<<Parse options, P. \ref{pr:p2t}>>
  //<<Parse input files, P. \ref{pr:p2t}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, P. \ref{pr:p2t}>>=
  "github.com/evolbioinf/fur/util"
#+end_src
#+begin_export latex
The usage consists of the actual usage message, an explanation of the
purpose of \ty{prim2tab}, and an example command.
#+end_export
#+begin_src go <<Set usage, P. \ref{pr:p2t}>>=
  u := "prim2tab [option]... [file]..."
  p := "Convert output of primer3 to table."
  e := "primt2tab primer3.out | sort -n"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, P. \ref{pr:p2t}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
There is only one option, the version.
#+end_export
#+begin_src go <<Declare options, P. \ref{pr:p2t}>>=
  optV := flag.Bool("v", false, "version")
#+end_src
#+begin_export latex
We import \ty{flag}.
#+end_export
#+begin_src go <<Imports, P. \ref{pr:p2t}>>=
  "flag"
#+end_src
#+begin_export latex
We parse the option and if the user requested the version, we print
it, which also stops \ty{prim2tab}.
#+end_export
#+begin_src go <<Parse options, P. \ref{pr:p2t}>>=
  flag.Parse()
  if *optV {
	  util.Version()
  }
#+end_src
#+begin_export latex
The remaining tokens on the command line are taken as input files. We
iterate over them and print the primers in a single table. We format
this table using a \ty{tabwriter}, which we construct and initialize
with column headers. Parsing of the input files is then delegated to
the function \ty{ParseFiles}, which applies the function \ty{scan} to
each file and in turn takes the \ty{tabwriter} as an argument. Having
parsed the input, we flush the \ty{tabwriter}.
#+end_export
#+begin_src go <<Parse input files, P. \ref{pr:p2t}>>=
  files := flag.Args()
  w := tabwriter.NewWriter(os.Stdout, 0, 1, 2, ' ', 0)
  fmt.Fprintf(w, "# Penalty\tForward\tReverse\tInternal\n")
  clio.ParseFiles(files, scan, w)
  w.Flush()
#+end_src
#+begin_export latex
We import \ty{tabwriter}, \ty{os}, and \ty{fmt}.
#+end_export
#+begin_src go <<Imports, P. \ref{pr:p2t}>>=
  "text/tabwriter"
  "os"
  "fmt"
#+end_src
#+begin_export latex
Inside \ty{scan} we retrieve the \ty{tabwriter} and iterate over the
lines in the current input file. As already mentioned, lines of
\ty{primer3} output have a key/value structure separated by an equal
sign, \ty{k=v} (Figure~\ref{fig:prim}). The only exception to this
rule is the last line, which is a single equal sign. So we split each
line at the equal sign, and if this results in two fields, we go on to
extract the desired data.
#+end_export
#+begin_src go <<Functions, P. \ref{pr:p2t}>>=
  func scan(r io.Reader, args ...interface{}) {
	  w := args[0].(*tabwriter.Writer)
	  sc := bufio.NewScanner(r)
	  for sc.Scan() {
		  fields := strings.Split(sc.Text(), "=")
		  if len(fields) == 2 {
			  //<<Extract data, P. \ref{pr:p2t}>>
		  }
	  }
  }
#+end_src
#+begin_export latex
We import \ty{io}, \ty{tabwriter}, \ty{bufio}, and \ty{strings}.
#+end_export
#+begin_src go <<Imports, P. \ref{pr:p2t}>>=
  "io"
  "text/tabwriter"
  "bufio"
  "strings"
#+end_src
#+begin_export latex
We extract the four columns we are looking for, penalty, forward,
reverse, and internal.
#+end_export
#+begin_src go <<Extract data, P. \ref{pr:p2t}>>=
  <<Extract penalty, P. \ref{pr:p2t}>>
  <<Extract forward primer, P. \ref{pr:p2t}>>
  <<Extract reverse primer, P. \ref{pr:p2t}>>
  <<Extract internal primer, P. \ref{pr:p2t}>>
#+end_src
#+begin_export latex
The penalty for primer pairs is reported as, for example,
\begin{verbatim}
PRIMER_PAIR_0_PENALTY=1.320714
\end{verbatim}
Since we need to cover all primer pairs, not just pair zero, we define a
regular expression for matching.
#+end_export
#+begin_src go <<Variables, P. \ref{pr:p2t}>>=
  var penaltyRE = regexp.MustCompile(
	  `PRIMER_PAIR_[0-9]+_PENALTY`)
#+end_src
#+begin_export latex
We import \ty{regexp}.
#+end_export
#+begin_src go <<Imports, P. \ref{pr:p2t}>>=
  "regexp"
#+end_src
#+begin_export latex
Now we can check for a match to pair penalty and if successful print
the value.
#+end_export
#+begin_src go <<Extract penalty, P. \ref{pr:p2t}>>=
  if penaltyRE.MatchString(fields[0]) {
	  fmt.Fprintf(w, "%s", fields[1])
  }
#+end_src
#+begin_export latex
A forward primer is reported as, for example,
\begin{verbatim}
PRIMER_LEFT_0_SEQUENCE=CGGCAATATCATAGACATCGT
\end{verbatim}
so we define the corresponding regular expression.
#+end_export
#+begin_src go <<Variables, P. \ref{pr:p2t}>>=
  var forwardRE = regexp.MustCompile(
	  `PRIMER_LEFT_[0-9]+_SEQUENCE`)
#+end_src
#+begin_export latex
We extract the forward primer.
#+end_export
#+begin_src go <<Extract forward primer, P. \ref{pr:p2t}>>=
  if forwardRE.MatchString(fields[0]) {
	  fmt.Fprintf(w, "\t%s", fields[1])
  }
#+end_src
#+begin_export latex
A reverse primer is reported as, for example,
\begin{verbatim}
PRIMER_RIGHT_0_SEQUENCE=CGGCAATATCATAGACATCGT
\end{verbatim}
and we define the corresponding regular expression.
#+end_export
#+begin_src go <<Variables, P. \ref{pr:p2t}>>=
  var reverseRE = regexp.MustCompile(
	  `PRIMER_RIGHT_[0-9]+_SEQUENCE`)
#+end_src
#+begin_export latex
We extract the reverse primer.
#+end_export
#+begin_src go <<Extract reverse primer, P. \ref{pr:p2t}>>=
  if reverseRE.MatchString(fields[0]) {
	  fmt.Fprintf(w, "\t%s", fields[1])
  }
#+end_src
#+begin_export latex
An internal primer is reported as, for example,
\begin{verbatim}
PRIMER_INTERNAL_0_SEQUENCE=TCACGACGATAATTATCTTT
\end{verbatim}
and we define the required regular expression.
#+end_export
#+begin_src go <<Variables, P. \ref{pr:p2t}>>=
  var internalRE = regexp.MustCompile(
	  `PRIMER_INTERNAL_[0-9]+_SEQUENCE`)
#+end_src
#+begin_export latex
We extract the internal primer and end the line with a linebreak.
#+end_export
#+begin_src go <<Extract internal primer, P. \ref{pr:p2t}>>=
  if internalRE.MatchString(fields[0]) {
	  fmt.Fprintf(w, "\t%s\n", fields[1])
  }
#+end_src
#+begin_export latex
We have finished \ty{prim2tab}, let's test it.
\section{Testing}
Our framework for testing \ty{prim2tab} has hooks for imports and the
testing logic.
#+end_export
#+begin_src go <<prim2tab_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, P. \ref{pr:p2t}>>
  )
  func TestPrim2tab(t *testing.T) {
	  //<<Testing, P. \ref{pr:p2t}>>
  }
#+end_src
#+begin_export latex
We construct one test and run it.
#+end_export
#+begin_src go <<Testing, P. \ref{pr:p2t}>>=
  //<<Construct test, P. \ref{pr:p2t}>>
  //<<Run test, P. \ref{pr:p2t}>>
#+end_src
#+begin_export latex
For testing, we apply \ty{prim2tab} to a file of \ty{primer3} output,
\ty{prim.out}.
#+end_export
#+begin_src go <<Construct test, P. \ref{pr:p2t}>>=
  test := exec.Command("./prim2tab", "prim.out")
#+end_src
#+begin_export latex
We import \ty{exec}.
#+end_export
#+begin_src go <<Testing imports, P. \ref{pr:p2t}>>=
  "os/exec"
#+end_src
#+begin_export latex
We run the test and compare the result we get to the result we want,
which is stored in the file \ty{r.txt}.
#+end_export
#+begin_src go <<Run test, P. \ref{pr:p2t}>>=
  get, err := test.Output()
  if err != nil {
	  t.Error(err)
  }
  want, err := os.ReadFile("r.txt")
  if err != nil {
	  t.Error(err)
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_export latex
We import \ty{os} and \ty{bytes}.
#+end_export
#+begin_src go <<Testing imports, P. \ref{pr:p2t}>>=
  "os"
  "bytes"
#+end_src
