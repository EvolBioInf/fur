#+begin_export latex
\section{Introduction}
The primer scores generated by \ty{scop} consist of sensitivity and
specificity values calculated on the basis of the given taxonomy. This
taxonomy might not be correct, so we double check it. The purpose of
the program \ty{cops} is to correct the primer scores returned by
\ty{scop}.

The program \ty{scop} returns the accessions of the strains it
classified as true positive, true negative, and false negative. These
accessions are read by the program \ty{cops}, together with the
accession of a reference stain, the name of the Blast database used by
\ty{scop}, and a threshold distance, $d_{\rm t}$. For every accession,
$i$, read as input, \ty{cops} calculates the distance to the reference
stains, $d_i$, and compares $d_i$ to $d_{\rm t}$. A true positive
should have $d_i\le d_{\rm t}$, otherwise it is reclassified as a
false positive. Similarly, a false positive should have $d_i > d_{\rm
  t}$, otherwise it is reclassified as a true positive. And a false
negative should have $d_i \le d_{\rm t}$, otherwise it is reclassified
as a true negative. These classifications are summarized in
Table~\ref{tab:cla}.
\begin{table}
  \caption{Reclassification of a taxon $i$ based on teh relationship
    between its distance to the reference strain, $d_i$, and the
    threshold distance, $d_{\rm t}$.}\label{tab:cla}
  \begin{center}
    \begin{tabular}{lll}
      \hline
      Original Classification & Expectation & Reclassification\\\hline
      true positive & $d_i\le d_{\rm t}$ & false positive\\
      false positive & $d_i > d_{\rm t}$ & true positive\\
      false negative & $d_i\le d_{\rm t}$ & true negative\\\hline
    \end{tabular}
  \end{center}
\end{table}
Figure~\ref{fig:sco} shows some example output from \ty{scop}; note
the rather low specificity score of 0.47.
\begin{figure}
  \begin{center}
    \fbox{
    \begin{minipage}{7.35cm}
      \verbatiminput{../cops/example.txt}
    \end{minipage}
    }
  \end{center}
  \caption{Example output from \ty{scop}; since no false negatives
    were found, the sensitivity is 1 and no false negatives are
    listed.}\label{fig:sco}
\end{figure}
The program \ty{cops} leaves the sensitivity unchanged but corrects
the specificity to X (Figure~\ref{fig:cop}). It also prints the remaining false positives and
their distance to the reference strain.
\begin{figure}
  \begin{center}
    \fbox{
    \begin{minipage}{7.35cm}
      \verbatiminput{../cops/cops.txt}
    \end{minipage}
    }
  \end{center}
\caption{Corrected primer scores using the data in
  Figure~\ref{fig:scop} as input.}\label{fig:cop}
\end{figure}

\section{Implementation}
Our outline of \ty{cops} contains hooks for imports and functions, and
for the logic of the main function.
\bpr{cops}{pr:cop}
#+end_export
#+begin_src go <<cops.go>>=
  package main

  import (
	  //<<Imports, Pr. \ref{pr:cop}>>
  )
  //<<Functions, Pr. \ref{pr:cop}>>
  func main() {
	  //<<Main function, Pr. \ref{pr:cop}>>
  }
#+end_src
#+begin_export latex
\epr In the main function we first prepare the error messages. Then we
set the usage, declare the options, parse the options, and parse the
input.
#+end_export
#+begin_src go <<Main function, Pr. \ref{pr:cop}>>=
  util.PrepareErrorMessages("cops")
  //<<Set usage, Pr. \ref{pr:cop}>>
  //<<Declare options, Pr. \ref{pr:cop}>>
  //<<Parse options, Pr. \ref{pr:cop}>>
  //<<Parse input, Pr. \ref{pr:cop}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "github.com/evolbioinf/fur/util"
#+end_src
#+begin_export latex
The usage consists of the actual usage message, an explanation of the
purpose of \ty{cops}, and an example command.
#+end_export
#+begin_src go <<Set usage, Pr. \ref{pr:cop}>>=
  u := "cops -d <db> [option]... [foo.txt]..."
  p := "Correct primer scores calculated with scop."
  e := "cops -d nt -r AE005174 -t 5e-4 scop.out"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
We declare the obligatory version option, \ty{-v}, and two mandatory
options, the database, \ty{-d}, and the accession of the reference
strain. In addition, the user can change the threshold distance from
its default value, $d_{\rm t}=10^{-3}$, and run \ty{phylonium} in
single-threaded mode, from default two-threaded.
#+end_export
#+begin_src go <<Declare options, Pr. \ref{pr:cop}>>=
  optV := flag.Bool("v", false, "version")
  optD := flag.String("d", "", "Blast datbase")
  optR := flag.String("r", "", "accession of reference target strain")
  optT := flag.Float64("t", 1e-3, "threshold distance")
  optS := flag.Bool("s", false, "single-threaded (default two-threaded)")
#+end_src
#+begin_export latex
We import \ty{flag}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "flag"
#+end_src
#+begin_export latex
We parse the options and respond to the version option, \ty{-v}, as
this stops \ty{cops}. Then we respond to the database option, \ty{-d},
the reference stain, \ty{-r}, and single-strandedness, \ty{-s}.
#+end_export
#+begin_src go <<Parse options, Pr. \ref{pr:cop}>>=
  flag.Parse()
  //<<Respond to \ty{-v}, Pr. \ref{pr:cop}>>
  //<<Respond to \ty{-d}, Pr. \ref{pr:cop}>>
  //<<Respond to \ty{-r}, Pr. \ref{pr:cop}>>
  //<<Respond to \ty{-s}, Pr. \ref{pr:cop}>>
#+end_src
#+begin_export latex
We print the version, if requested.
#+end_export
#+begin_src go <<Respond to \ty{-v}, Pr. \ref{pr:cop}>>=
  if *optV {
	  util.Version()
  }
#+end_src
#+begin_export latex
If the user didn't supply a Blast database, we bail with a friendly
message.
#+end_export
#+begin_src go <<Respond to \ty{-d}, Pr. \ref{pr:cop}>>=
  if *optD == "" {
	  log.Fatal("please supply a Blast database")
  }
#+end_src
#+begin_export latex
We import \ty{log}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "log"
#+end_src
#+begin_export latex
Similarly, if the user didn't supply a reference strain, we bail and
send a friendly message.
#+end_export
#+begin_src go <<Respond to \ty{-r}, Pr. \ref{pr:cop}>>=
  if *optR == "" {
	  log.Fatal("please supply a reference strain")
  }
#+end_src
#+begin_export latex
The number of threads is two, unless the user opted for
single-threaded.
#+end_export
#+begin_src go <<Respond to \ty{-s}, Pr. \ref{pr:cop}>>=
  nt := 2
  if *optS {
	  nt = 1
  }
#+end_src
#+begin_export latex
The remaining tokens on the command line are interpreted as file
names. We parse these files using the function \ty{ParseFiles}, which
applies the function \ty{parse} to each one of them. The function
\ty{parse} in turn takes as arguments the name of the Blast database,
the reference strain, the threshold distance, and the number of
threads.
#+end_export
#+begin_src go <<Parse input, Pr. \ref{pr:cop}>>=
  files := flag.Args()
  clio.ParseFiles(files, parse, *optD, *optR, *optT, nt)
#+end_src
#+begin_export latex
Inside \ty{parse}, we retrieve the arguments we just passed. Then we
split the file into reports generated by \ty{scop}
(Figure~\ref{fig:scop}). We analyze each report, correct it, and print
a corrected version.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:cop}>>=
  func parse(r io.Reader, args ...interface{}) {
	  //<<Retrieve arguments, Pr. \ref{pr:cop}>>
	  d, e := io.ReadAll(r)
	  util.Check(e)
	  reports := bytes.Split(d, []byte("PrimerSet"))
	  reports = reports[1:]
	  for _, report := range reports {
		  //<<Analyze report, Pr. \ref{pr:cop}>>
		  //<<Correct report, Pr. \ref{pr:cop}>>
		  //<<Print corrected report, Pr. \ref{pr:cop}>>
	  }
  }
#+end_src
#+begin_export latex
We import \ty{io} and \ty{bytes}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "io"
  "bytes"
#+end_src
#+begin_export latex
We retrieve the database, the reference, the threshold, and the number
of threads.
#+end_export
#+begin_src go <<Retrieve arguments, Pr. \ref{pr:cop}>>=
  db := args[0].(string)
  re := args[1].(string)
  dt := args[2].(float64)
  nt := args[3].(int)
#+end_src
#+begin_export latex
We split the report into its constituent lines and check we have at
least three lines and no more than six. If not, we bail with a
friendly message. If we're still going, we store the name of the
primer set. Then we skip the lines containing the sensitivity and
specificity and store the accessions of true positives, false
positives, and false negatives in a map
#+end_export
#+begin_src go <<Analyze report, Pr. \ref{pr:cop}>>=
  lines := bytes.Split(report, []byte("\n"))
  l := len(lines)
  if l < 3 || l > 6 {
	  log.Fatalf("mal-formed report:\n%s\n", string(report))
  }
  primerSet := string(bytes.Fields(lines[0])[1])
  lines = lines[3:]
  accessions := make(map[string][]string)
  //<<Store accessions, Pr. \ref{pr:cop}>>
#+end_src
#+begin_export latex
We iterate over the remaining lines and split them into their
constituent fields. The first field minus the trailing colon is the
accession type, the remaining fields are the actual accessions.
#+end_export
#+begin_src go <<Store accessions, Pr. \ref{pr:cop}>>=
  for _, line := range lines {
	  fields := bytes.Fields(line)
	  if len(fields) > 0 {
		  k := string(fields[0][:len(fields[0])-1])
		  for i := 1; i < len(fields); i++ {
			  v := string(fields[i])
			  accessions[k] = append(accessions[k], v)
		  }
	  }
  }
#+end_src
#+begin_export latex
We get the reference sequence and correct the true positives, the
false positives, and the false negatives.
#+end_export
#+begin_src go <<Correct report, Pr. \ref{pr:cop}>>=
  //<<Get reference sequence, Pr. \ref{pr:cop}>>
  //<<Correct true positives, Pr. \ref{pr:cop}>>
  //<<Correct false positives, Pr. \ref{pr:cop}>>
  //<<Correct false negatives, Pr. \ref{pr:cop}>>
#+end_src
#+begin_export latex
We retrieve the reference sequence from the Blast database using the
program \ty{blastdbcmd} and store it in a unique file. This file is
deleted when the function \ty{parse} returns.
#+end_export
#+begin_src go <<Get reference sequence, Pr. \ref{pr:cop}>>=
  cmd := exec.Command("blastdbcmd", "-db", db, "-entry", re)
  out, err := cmd.CombinedOutput()
  if err != nil {
	  log.Fatalf("%s\n", out)
  }
  f, err := os.CreateTemp("", "ref*.fasta")
  rf := f.Name()
  util.Check(err)
  err = os.WriteFile(rf, out, 0644)
  util.Check(err)
  defer os.Remove(rf)
#+end_src
#+begin_export latex
We import \ty{exec} and \ty{os}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "os/exec"
  "os"
#+end_src
#+begin_export latex
We iterate over the true positive accessions and analyze each one. The
analysis might turn up new false positives, which we store. We also
store and count the old true positives and after the loop reslice
their storage accordingly.
#+end_export
#+begin_src go <<Correct true positives, Pr. \ref{pr:cop}>>=
  nfp := make([]string, 0)
  n := 0
  accs := accessions["TruePositives"]
  for _, acc := range accs {
	  //<<Analyze true positive, Pr. \ref{pr:cop}>>
  }
  accessions["TruePositives"] = accs[:n]
#+end_src
#+begin_export latex
We calculate the distance between the reference and the current
accession by calling the function \ty{dist}, which we still need to
write. Then we classify the accession as either a true positive or a
new false positive.
#+end_export
#+begin_src go <<Analyze true positive, Pr. \ref{pr:cop}>>=
  di := dist(rf, acc, db, nt)
  if di <= dt {
	  accs[n] = acc
	  n++
  } else {
	  nfp = append(nfp, acc)
  }
#+end_src
#+begin_export latex
Inside the function \ty{dist}, we get the query sequence, run
\ty{phylonium}, and extract the desired $d_i$ from its output.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:cop}>>=
  func dist(rf, query, db string, nt int) float64 {
	  di := 0.0
	  //<<Get query sequence, Pr. \ref{pr:cop}>>
	  //<<Run \ty{phylonium}, Pr. \ref{pr:cop}>>
	  //<<Extract $d_i$, Pr. \ref{pr:cop}>>
	  return di
  }
#+end_src
#+begin_export latex
Like the reference sequence, we get the query sequence from the Blast
database and store it in a file with a unique name. This file is
deleted again when \ty{dist} returns.
#+end_export
#+begin_src go <<Get query sequence, Pr. \ref{pr:cop}>>=
  cmd := exec.Command("blastdbcmd", "-db", db, "-entry", query)
  out, err := cmd.CombinedOutput()
  if err != nil {
	  log.Fatalf("%s\n", out)
  }
  f, err := os.CreateTemp("", "query*.fasta")
  util.Check(err)
  qf := f.Name()
  err = os.WriteFile(qf, out, 0644)
  util.Check(err)
  defer os.Remove(qf)
#+end_src
#+begin_export latex
We run \ty{phylonium} with the given number of threads and store its
output.
#+end_export
#+begin_src go <<Run \ty{phylonium}, Pr. \ref{pr:cop}>>=
  nts := strconv.Itoa(nt)
  cmd = exec.Command("phylonium", "-t", nts, rf, qf)
  out, err = cmd.Output()
  util.Check(err)
#+end_src
#+begin_export latex
We import \ty{strconv}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "strconv"
#+end_src
#+begin_export latex
The output from \ty{phylonium} looks like this:
\begin{verbatim}
2
s1  0.0000e+00  1.5175e-03
s2  1.5175e-03  0.0000e+00
\end{verbatim}
So $d_i$ is either the third token in the second row or the second
token in the third row. We'll go for the third token in the second
row.
#+end_export
#+begin_src go <<Extract $d_i$, Pr. \ref{pr:cop}>>=
  lines := bytes.Split(out, []byte("\n"))
  if len(lines) < 3 {
	  m := "mal-formed output from phylonium: %s\n"
	  log.Fatalf(m, out)
  }
  fields := bytes.Fields(lines[1])
  di, err = strconv.ParseFloat(string(fields[2]), 64)
  util.Check(err)
#+end_src
#+begin_export latex
Having finished correcting the true positives, we now turn to the
false positives. We iterate over their accessions and analyze each
one. The analysis might uncover new true positives, which we store.
#+end_export
#+begin_src go <<Correct false positives, Pr. \ref{pr:cop}>>=
  ntp := make([]string, 0)
  n = 0
  accs = accessions["FalsePositives"]
  for _, acc := range accs {
	  //<<Analyze false positive, Pr. \ref{pr:cop}>>
  }
  accessions["FalsePositives"] = accs[:n]
#+end_src
#+begin_export latex
Depending on the distance between the reference and the currenct
accession, we are dealing either with a ``true'' false positive, or a
new true positive.
#+end_export
#+begin_src go <<Analyze false positive, Pr. \ref{pr:cop}>>=
  di := dist(rf, acc, db, nt)
  if di > dt {
	  accs[n] = acc
	  n++
  } else {
	  ntp = append(ntp, acc)
  }
#+end_src
#+begin_export latex
In our final correction step we analyze the accessions of the false
negatives, which may in fact be true negatives. But since we do not
count true negatives, we don't store the reclassified accessions
either.
#+end_export
#+begin_src go <<Correct false negatives, Pr. \ref{pr:cop}>>=
  n = 0
  accs = accessions["FalseNegatives"]
  for _, acc := range accs {
	  //<<Analyze false negative, Pr. \ref{pr:cop}>>
  }
  accessions["FalseNegatives"] = accs[:n]
#+end_src
#+begin_export latex
The distance between the reference and the current accession allows us
to distinguish between ``true'' false negatives and true negatives.
#+end_export
#+begin_src go <<Analyze false negative, Pr. \ref{pr:cop}>>=
  di := dist(rf, acc, db, nt)
  if di <= dt {
	  accs[n] = acc
	  n++
  }
#+end_src
#+begin_export latex
We construct slices of true positives, false positives, and false
negative accessions. From the lengths of these slices we calculate the
sensitivity and the specificity of our primer set. That suffices for
printing the first three lines of our report, as shown in
Figure~\ref{fig:cops}. Then we print the corrected accession lists.
#+end_export
#+begin_src go <<Print corrected report, Pr. \ref{pr:cop}>>=
  //<<Construct slices of accessions, Pr. \ref{pr:cop}>>
  //<<Calculate sensitivity, Pr. \ref{pr:cop}>>
  //<<Calculate specificity, Pr. \ref{pr:cop}>>
  //<<Print first three lines of report, Pr. \ref{pr:cop}>>
  //<<Print accessions, Pr. \ref{pr:cop}>>
#+end_src
#+begin_export latex
We merge the approved true positives and the new positives into 
single slices. We also sort the accessions.
#+end_export
#+begin_src go <<Construct slices of accessions, Pr. \ref{pr:cop}>>=
  tps := accessions["TruePositives"]
  tps = append(tps, ntp...)
  sort.Strings(tps)
  fps := accessions["FalsePositives"]
  fps = append(fps, nfp...)
  sort.Strings(fps)
  fns := accessions["FalseNegatives"]
  sort.Strings(fns)
#+end_src
#+begin_export latex
We import \ty{sort}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "sort"
#+end_src
#+begin_export latex
Let $t_{\rm p}$ be the number of true positives and $f_{\rm n}$ the
number of false negatives, then the sensitivity is defined as the
fraction of taxa that should have been identified,
\[
s_{\rm n}=\frac{t_{\rm p}}{t_{\rm p}+f_{\rm n}}.
\]
#+end_export
#+begin_src go <<Calculate sensitivity, Pr. \ref{pr:cop}>>=
  tp := float64(len(tps))
  fn := float64(len(fns))
  sn := tp / (tp + fn)
#+end_src
#+begin_export latex
Let also $f_{\rm p}$ be the number of false positives, then the
specificity is defined as the fraction of true hits,
\[
s_{\rm p} = \frac{t_{\rm p}}{t_{\rm p}+f_{\rm p}}.
\]
#+end_export
#+begin_src go <<Calculate specificity, Pr. \ref{pr:cop}>>=
  fp := float64(len(fps))
  sp := tp / (tp + fp)
#+end_src
#+begin_export latex
The first three lines of the report consist of the primer set, the
sensitivity, and the specificity.
#+end_export
#+begin_src go <<Print first three lines of report, Pr. \ref{pr:cop}>>=
  fmt.Printf("PrimerSet:\t%s\n", primerSet)
  fmt.Printf("Sensitivity:\t%.2g\n", sn)
  fmt.Printf("Specificity:\t%.2g\n", sp)
#+end_src
#+begin_export latex
We import \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "fmt"
#+end_src
#+begin_export latex
We print the accessions of the true positives, the false positives,
and the false negatives, in that order.
#+end_export
#+begin_src go <<Print accessions, Pr. \ref{pr:cop}>>=
  if len(tps) > 0 {
	  //<<Print true positives, Pr. \ref{pr:cop}>>
  }
  if len(fps) > 0 {
	  //<<Print false positives, Pr. \ref{pr:cop}>>
  }
  if len(fns) > 0 {
	  //<<Print false negatives, Pr. \ref{pr:cop}>>
  }
#+end_src
#+begin_export latex
We print the true positive as one blank-delimited row.
#+end_export
#+begin_src go <<Print true positives, Pr. \ref{pr:cop}>>=
  fmt.Printf("TruePositives:\t%s", tps[0])
  for i := 1; i < len(tps); i++ {
	  fmt.Printf(" %s", tps[i])
  }
  fmt.Printf("\n")
#+end_src
#+begin_export latex
We also print the false positives as a blank-delimited row.
#+end_export
#+begin_src go <<Print false positives, Pr. \ref{pr:cop}>>=
  fmt.Printf("FalsePositives:\t%s", fps[0])
  for i := 1; i < len(fps); i++ {
	  fmt.Printf(" %s", fps[i])
  }
  fmt.Printf("\n")
#+end_src
#+begin_export latex
Finally, we print the false negatives as a blank-delimited row.
#+end_export
#+begin_src go <<Print false negatives, Pr. \ref{pr:cop}>>=
  fmt.Printf("FalseNegatives:\t%s", fns[0])
  for i := 1; i < len(fns); i++ {
	  fmt.Printf(" %s", fns[i])
  }
  fmt.Printf("\n")
#+end_src
#+begin_export latex
We have finished \ty{cops}, let's test it.
\section{Testing}
#+end_export
