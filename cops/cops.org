#+begin_export latex
\section{Introduction}
The primer scores generated by \ty{scop} consist of sensitivity and
specificity values calculated on the basis of the given taxonomy. This
taxonomy might not be correct, so we double check it. The purpose of
the program \ty{cops} is to correct the primer scores returned by
\ty{scop}.

The program \ty{scop} returns the accessions of the strains it
classified as true positive, true negative, and false negative. These
accessions are read by the program \ty{cops}, together with the
accession of a reference stain, the name of the Blast database used by
\ty{scop}, and a threshold distance, $d_{\rm t}$. For every accession,
$i$, read as input, \ty{cops} calculates the distance to the reference
stains, $d_i$, and compares $d_i$ to $d_{\rm t}$. A true positive
should have $d_i\le d_{\rm t}$, otherwise it is reclassified as a
false positive. Similarly, a false positive should have $d_i > d_{\rm
  t}$, otherwise it is reclassified as a true positive. And a false
negative should have $d_i \le d_{\rm t}$, otherwise it is reclassified
as a true negative. These classifications are summarized in
Table~\ref{tab:cla}.
\begin{table}
  \caption{Reclassification of a taxon $i$ based on the relationship
    between its distance to the reference strain, $d_i$, and the
    threshold distance, $d_{\rm t}$.}\label{tab:cla}
  \begin{center}
    \begin{tabular}{lll}
      \hline
      Original Classification & Expectation & Reclassification\\\hline
      true positive & $d_i\le d_{\rm t}$ & false positive\\
      false positive & $d_i > d_{\rm t}$ & true positive\\
      false negative & $d_i\le d_{\rm t}$ & true negative\\\hline
    \end{tabular}
  \end{center}
\end{table}

Figure~\ref{fig:sco} shows example output from \ty{scop} taken from an
analysis of \emph{E. coli} O157:H7. Two things are remarkable about
this output. First, accession AE005174, which is listed as a false
positive, happens to correspond to the type strain on O157:H7,
EDL933. So it certainly isn't a false positive. The reason for its
misclassification is that the header of AE005174 only contains the
term ``genome'', but not ``complete genome'', which is required by
\ty{scop} for inclusion in the set of target accessions. The second
thing to note is the low specificity of 0.47.
\begin{figure}
  \begin{center}
    \fbox{
    \begin{minipage}{7.45cm}
      \verbatiminput{../cops/example.txt}
    \end{minipage}
    }
  \end{center}
  \caption{Example output from \ty{scop}; since no false negatives
    were found, the sensitivity is 1 and no false negatives are
    listed.}\label{fig:sco}
\end{figure}
The program \ty{cops} leaves the sensitivity unchanged but corrects
the specificity to a more respectable 0.97 (Figure~\ref{fig:cops1}).
\begin{figure}
  \begin{center}
    \fbox{
    \begin{minipage}{7.35cm}
      \verbatiminput{../cops/cops1.txt}
    \end{minipage}
    }
  \end{center}
\caption{Corrected primer scores using the data in
  Figure~\ref{fig:sco} as input.}\label{fig:cops1}
\end{figure}

The user can also request that the accessions are annotated with
distances to the reference strain. Figure~\ref{fig:cops2} the distance
to the reference, zero, and the distance to the true positive that is
alphabetically next, $7\times 10^{-4}$. In contrast, the two distance
to the false positives shown are greater than 1\%.
\begin{figure}
  \begin{center}
    \fbox{
    \begin{minipage}{9.9cm}
      \verbatiminput{../cops/cops2.txt}
    \end{minipage}
    }
  \end{center}
\caption{Corrected primer scores with distances to the reference using
  the data in Figure~\ref{fig:sco} as input.}\label{fig:cops2}
\end{figure}

In this example analysis \ty{cops} returns distances for 334 true
positives and 11 false positives. Figure~\ref{fig:dist} shows the
distribution of all log-distances, except for the zero distance. Note
the major mode centered on -3.5 for the true positives and the minor
mode between -2 and -1.5 for the 11 false positives. Their existence
is probably due to horizontal transfer of the marker.
\begin{figure}
  \begin{center}
    \includegraphics{../cops/dist}
  \end{center}
  \caption{Distribution of 345 log-distances between genomes \emph{in
    silico} amplified by \ty{scop} and the type strain of
    \emph{E. coli} O157:H7, EDL933; note the false positives between
    -2 and -1.5.}\label{fig:dist}
\end{figure}
\section{Implementation}
Our outline of \ty{cops} contains hooks for imports and functions, and
for the logic of the main function.
\bpr{cops}{pr:cop}
#+end_export
#+begin_src go <<cops.go>>=
  package main

  import (
	  //<<Imports, Pr. \ref{pr:cop}>>
  )
  //<<Functions, Pr. \ref{pr:cop}>>
  func main() {
	  //<<Main function, Pr. \ref{pr:cop}>>
  }
#+end_src
#+begin_export latex
\epr In the main function we first prepare the error messages. Then we
set the usage, declare the options, parse the options, and parse the
input.
#+end_export
#+begin_src go <<Main function, Pr. \ref{pr:cop}>>=
  util.PrepareErrorMessages("cops")
  //<<Set usage, Pr. \ref{pr:cop}>>
  //<<Declare options, Pr. \ref{pr:cop}>>
  //<<Parse options, Pr. \ref{pr:cop}>>
  //<<Parse input, Pr. \ref{pr:cop}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "github.com/evolbioinf/fur/util"
#+end_src
#+begin_export latex
The usage consists of the actual usage message, an explanation of the
purpose of \ty{cops}, and an example command.
#+end_export
#+begin_src go <<Set usage, Pr. \ref{pr:cop}>>=
  u := "cops -d <db> -r <ref> -t <d> [option]... [foo.txt]..."
  p := "Correct primer scores calculated with scop."
  e := "cops -d nt -r AE005174 -t 2e-3 scop.out"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
We declare the obligatory version option, \ty{-v}, and three mandatory
options, the database, \ty{-d}, the accession of the reference strain,
and the threshold distance to the reference. In addition, the user can
run \ty{phylonium} with a different number of threads than the number
of CPUs, print the distances as part of the output, and include the
true positives in the checking. You might wander why anyone would want
to also double-check the true positives. However, it is possible to
find the marker in the wrong genome that has been misclassified as
target. This is highly unlikely, but not impossible, which is why we
don't routinely include the true positives in the checking, but at the
same time don't deny the user the possibility to do so.
#+end_export
#+begin_src go <<Declare options, Pr. \ref{pr:cop}>>=
  optV := flag.Bool("v", false, "version")
  optD := flag.String("d", "", "Blast datbase")
  optR := flag.String("r", "",
	  "accession of reference target strain")
  optT := flag.Float64("t", 0, "threshold distance to reference")
  numThreads := runtime.NumCPU()
  optTT := flag.Int("T", numThreads, "number of threads")
  optDD := flag.Bool("D", false, "include distances in output")
  optP := flag.Bool("p", false, "also check true positives " +
	  "(default only check false positives and false negatives)")
#+end_src
#+begin_export latex
We import \ty{flag} and \ty{runtime}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "flag"
  "runtime"
#+end_src
#+begin_export latex
We parse the options and respond to the version option, \ty{-v}, as
this stops \ty{cops}. Then we ensure the mandatory options have been
set.
#+end_export
#+begin_src go <<Parse options, Pr. \ref{pr:cop}>>=
  flag.Parse()
  //<<Respond to \ty{-v}, Pr. \ref{pr:cop}>>
  //<<Ensure mandatory options, Pr. \ref{pr:cop}>>
#+end_src
#+begin_export latex
If the user requested the version, we print it.
#+end_export
#+begin_src go <<Respond to \ty{-v}, Pr. \ref{pr:cop}>>=
  if *optV {
	  util.Version()
  }
#+end_src
#+begin_export latex
We make sure the user supplied a database, a reference strain, and a
threshold distance. We quit with a friendly message if that's not the
case.
#+end_export
#+begin_src go <<Ensure mandatory options, Pr. \ref{pr:cop}>>=
  if *optD == "" {
	  log.Fatal("please supply a Blast database")
  }
  if *optR == "" {
	  log.Fatal("please supply a reference strain")
  }
  if *optT == 0 {
	  log.Fatal("please supply the threshold " +
		  "distance to the reference")
  }
#+end_src
#+begin_export latex
We import \ty{log}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "log"
#+end_src
#+begin_export latex
The remaining tokens on the command line are interpreted as file
names. We parse these files using the function \ty{ParseFiles}, which
applies the function \ty{parse} to each one of them. The function
\ty{parse} in turn takes as arguments the name of the Blast database,
the reference strain, the threshold distance, the number of threads,
whether or not to include the distances in the output, and whether or
not to include the true positives.
#+end_export
#+begin_src go <<Parse input, Pr. \ref{pr:cop}>>=
  files := flag.Args()
  clio.ParseFiles(files, parse, *optD, *optR,
	  (*optT), *optTT, *optDD, *optP)
#+end_src
#+begin_export latex
Inside \ty{parse}, we retrieve the arguments we just passed. Then we
split the file into reports generated by \ty{scop}
(Figure~\ref{fig:sco}). We analyze each report, correct it, and print
a corrected version.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:cop}>>=
  func parse(r io.Reader, args ...interface{}) {
	  //<<Retrieve arguments, Pr. \ref{pr:cop}>>
	  d, e := io.ReadAll(r)
	  util.Check(e)
	  reports := bytes.Split(d, []byte("PrimerSet"))
	  reports = reports[1:]
	  for _, report := range reports {
		  //<<Analyze report, Pr. \ref{pr:cop}>>
		  //<<Correct report, Pr. \ref{pr:cop}>>
		  //<<Print corrected report, Pr. \ref{pr:cop}>>
	  }
  }
#+end_src
#+begin_export latex
We import \ty{io} and \ty{bytes}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "io"
  "bytes"
#+end_src
#+begin_export latex
We retrieve the database, the reference, the threshold, the number of
threads, the distance switch, and the true positives switch.
#+end_export
#+begin_src go <<Retrieve arguments, Pr. \ref{pr:cop}>>=
  db := args[0].(string)
  re := args[1].(string)
  dt := args[2].(float64)
  nt := args[3].(int)
  pd := args[4].(bool)
  truePos := args[5].(bool)
#+end_src
#+begin_export latex
We split the report into its constituent lines and check whether a
terminal carriage return created an empty line, which we cut. Then we
check we have at least three lines and no more than six. Note at this
point that the terminal If not, we bail with a friendly message. If
we're still going, we store the name of the primer set. Then we skip
the lines containing the sensitivity and specificity and store the
accessions of true positives, false positives, and false negatives in
a map.
#+end_export
#+begin_src go <<Analyze report, Pr. \ref{pr:cop}>>=
  lines := bytes.Split(report, []byte("\n"))
  if len(lines[len(lines)-1]) == 0 {
	  lines = lines[:len(lines)-1]
  }
  l := len(lines)
  if l < 3 || l > 6 {
	  log.Fatalf("mal-formed report:\n%s\n", string(report))
  }
  primerSet := string(bytes.Fields(lines[0])[1])
  lines = lines[3:]
  accessions := make(map[string][]string)
  //<<Store accessions, Pr. \ref{pr:cop}>>
#+end_src
#+begin_export latex
We iterate over the remaining lines and split them into their
constituent fields. The first field minus the trailing colon is the
accession type, the remaining fields are the actual accessions.
#+end_export
#+begin_src go <<Store accessions, Pr. \ref{pr:cop}>>=
  for _, line := range lines {
	  fields := bytes.Fields(line)
	  if len(fields) > 0 {
		  k := string(fields[0][:len(fields[0])-1])
		  for i := 1; i < len(fields); i++ {
			  v := string(fields[i])
			  accessions[k] = append(accessions[k],
				  v)
		  }
	  }
  }
#+end_src
#+begin_export latex
Correcting the report essentially means, running \ty{phyonium} on all
input accessions. We do this by first constructing a directory for
holing the sequence files on which we run \ty{phylonium}. Then we
place the sequences into that directory, run \ty{phylonium}, and read
the distance matrix it produces. These distances allow us to correct
the false positives, the false negatives, and, if desired, the true
positives. True positives might turn out to be new false positives,
for which we reserve a slice.
#+end_export
#+begin_src go <<Correct report, Pr. \ref{pr:cop}>>=
  //<<Create directory for sequence files, Pr. \ref{pr:cop}>>
  //<<Get sequences, Pr. \ref{pr:cop}>>
  //<<Run \ty{phylonium}, Pr. \ref{pr:cop}>>
  //<<Read distance matrix, Pr. \ref{pr:cop}>>
  //<<Correct false positives, Pr. \ref{pr:cop}>>
  //<<Correct false negatives, Pr. \ref{pr:cop}>>
  nfp := make([]string, 0)
  if truePos {
	  //<<Correct true positives, Pr. \ref{pr:cop}>>
  }
#+end_src
#+begin_export latex
We create a temporary directory, which is deleted when \ty{parse}
returns.
#+end_export
#+begin_src go <<Create directory for sequence files, Pr. \ref{pr:cop}>>=
  td, err := os.MkdirTemp("", "temp*")
  util.Check(err)
  defer os.RemoveAll(td)
#+end_src
#+begin_export latex
To get the sequences, we write the accessions to a, query the blast
database with \ty{blastdbcmd}, and write the sequences returned by
\ty{blastdbcmd} to separate files.
#+end_export
#+begin_src go <<Get sequences, Pr. \ref{pr:cop}>>=
  //<<Write accessions to file, Pr. \ref{pr:cop}>>
  //<<Run \ty{blastdbcmd}, Pr. \ref{pr:cop}>>
  //<<Write sequences to files, Pr. \ref{pr:cop}>>
#+end_src
#+begin_export latex
We open a file for the accessions and write the reference accession,
followed by the query accessions.
#+end_export
#+begin_src go <<Write accessions to file, Pr. \ref{pr:cop}>>=
  //<<Open accessions file, Pr. \ref{pr:cop}>>
  //<<Write reference accession, Pr. \ref{pr:cop}>>
  //<<Write query accessions, Pr. \ref{pr:cop}>>
#+end_src
#+begin_export latex
The accessions file is inside the temporary directory, which means it
is also removed at the end of the run.
#+end_export
#+begin_src go <<Open accessions file, Pr. \ref{pr:cop}>>=
  f, err := os.CreateTemp(td, "acc*.txt")
  util.Check(err)
  defer f.Close()
#+end_src
#+begin_export latex
When dealing with the reference accession, we first need its exact
version, that is, including the suffix for the sequence version. We
get this by a call to \ty{blastdbcmd}. The resulting accession is
terminated by a newline, which we remove, before we print it.
#+end_export
#+begin_src go <<Write reference accession, Pr. \ref{pr:cop}>>=
  cmd := exec.Command("blastdbcmd", "-db", db, "-entry", re,
	  "-outfmt", "%a")
  out, err := cmd.CombinedOutput()
  if err != nil {
	  log.Fatalf("%s\n", out)
  }
  re = string(out[:len(out)-1])
  fmt.Fprintf(f, "%s\n", re)
#+end_src
#+begin_export latex
We import \ty{exec} and \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "os/exec"
  "fmt"
#+end_src
#+begin_export latex
We write the accessions of the false positives, the false negatives,
and, if desired, the true positives.
#+end_export
#+begin_src go <<Write query accessions, Pr. \ref{pr:cop}>>=
  keys := []string{"FalsePositives", "FalseNegatives"}
  if truePos {
	  keys = append(keys, "TruePositives")
  }
  for _, key := range keys {
	  accs := accessions[key]
	  if accs != nil {
		  //<<Write accessions, Pr. \ref{pr:cop}>>
	  }
  }
#+end_src
#+begin_export latex
We iterate over the current set of accessions and print each one.
#+end_export
#+begin_src go <<Write accessions, Pr. \ref{pr:cop}>>=
  for _, acc := range accs {
	  fmt.Fprintf(f, "%s\n", acc)
  }
#+end_src
#+begin_export latex
We run \ty{blastdbccmd} in batch mode to retrieve the sequences
corresponding to the accessions we just wrote to file.
#+end_export
#+begin_src go <<Run \ty{blastdbcmd}, Pr. \ref{pr:cop}>>=
  cmd = exec.Command("blastdbcmd", "-db", db, "-entry_batch", f.Name())
  out, err = cmd.CombinedOutput()
  if err != nil {
	  log.Fatalf("%s\n", out)
  }
#+end_src
#+begin_export latex
We iterate over the sequences returned by \ty{blastdbcmd} and write
each one in a separate file inside the temporary directory. The file
names are the sequence accessions with suffix \ty{.fasta}.
#+end_export
#+begin_src go <<Write sequences to files, Pr. \ref{pr:cop}>>=
  sc := fasta.NewScanner(bytes.NewReader(out))
  for sc.ScanSequence() {
	  seq := sc.Sequence()
	  fn := strings.Fields(seq.Header())[0]
	  f, err := os.Create(td + "/" + fn + ".fasta")
	  util.Check(err)
	  fmt.Fprintf(f, "%s\n", seq)
	  f.Close()
  }
#+end_src
#+begin_export latex
We import \ty{fasta}, \ty{strings}, \ty{bytes}, and \ty{os}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "github.com/evolbioinf/fasta"
  "strings"
  "bytes"
  "os"
#+end_src
#+begin_export latex
We run \ty{phylonium} with the given number of threads and store its
output. Note that we construct the paths of the input files using the
\ty{Glob} function of \ty{filepath}, because direct submission of an
expandable name doesn't work---we are in Go, not in Unix. Also, in the
actual run of \ty{phylonium} we ignore the error returned as this may
be non-zero if the homology is low, but a distance was still
returned. This is a bit risky, but still better than obscurely failing
whenever a mildly divergent sequence is included in the analysis.
#+end_export
#+begin_src go <<Run \ty{phylonium}, Pr. \ref{pr:cop}>>=
  cmd = exec.Command("phylonium")
  nts := strconv.Itoa(nt)
  args := []string{"phylonium", "-t", nts, "-r",
	  td + "/"+ re + ".fasta"}
  p, err := filepath.Glob(td + "/*.fasta")
  util.Check(err)
  args = append(args, p...)
  cmd.Args = args
  out, _ = cmd.Output()
#+end_src
#+begin_export latex
We import \ty{strconv} and \ty{filepath}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "strconv"
  "path/filepath"
#+end_src
#+begin_export latex
We read the distance matrix or, failing that, give up.
#+end_export
#+begin_src go <<Read distance matrix, Pr. \ref{pr:cop}>>=
  var mat *dist.DistMat
  r := bytes.NewReader(out)
  scanner := dist.NewScanner(r)
  if scanner.Scan() {
	  mat = scanner.DistanceMatrix()
  } else {
	  log.Fatal("couldn't read distance matrix")
  }
#+end_src
#+begin_export latex
We import \ty{dist}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "github.com/evolbioinf/dist"
#+end_src
#+begin_export latex
In order to correct the given classification, we first need a map
between accessions and positions in the distance matrix. Using this
map, we look up the index of the reference sequence, \ty{ri}. Then we
iterate over the false positive accessions and analyze each one. This
analysis might uncover new true positives, which we store.
#+end_export
#+begin_src go <<Correct false positives, Pr. \ref{pr:cop}>>=
  accMap := make(map[string]int)
  for i, name := range mat.Names {
	  accMap[name] = i
  }
  ri := accMap[re]
  ntp := make([]string, 0)
  n := 0
  accs := accessions["FalsePositives"]
  for _, acc := range accs {
	  //<<Analyze false positive, Pr. \ref{pr:cop}>>
  }
  accessions["FalsePositives"] = accs[:n]
#+end_src
#+begin_export latex
We look up the distance between the reference and the current
accession, $d_i$. Comparison of $d_i$ to the threshold distance,
$d_{\rm t}$, allows us to determine whether we are dealing with a
``true'' false positive, or a new true positive.
#+end_export
#+begin_src go <<Analyze false positive, Pr. \ref{pr:cop}>>=
  j := accMap[acc]
  di := mat.Matrix[ri][j]
  if di > dt {
	  accs[n] = acc
	  n++
  } else {
	  ntp = append(ntp, acc)
  }
#+end_src
#+begin_export latex
Having correcte the false positives, we now analyze the false
negatives, which may in fact be true negatives. But since we do not
count true negatives, we don't store the reclassified accessions
either.
#+end_export
#+begin_src go <<Correct false negatives, Pr. \ref{pr:cop}>>=
  n = 0
  accs = accessions["FalseNegatives"]
  for _, acc := range accs {
	  //<<Analyze false negative, Pr. \ref{pr:cop}>>
  }
  accessions["FalseNegatives"] = accs[:n]
#+end_src
#+begin_export latex
The distance between the reference and the current accession allows us
to distinguish between ``true'' false negatives and true negatives.
#+end_export
#+begin_src go <<Analyze false negative, Pr. \ref{pr:cop}>>=
  i := accMap[re]
  j := accMap[acc]
  di := mat.Matrix[i][j]
  if di <= dt {
	  accs[n] = acc
	  n++
  }
#+end_src
#+begin_export latex
In our final correction step we analyze the accessions of the true
positives, which may in fact be false positives, which we store. We
also store and count the old true positives and after the loop reslice
their storage accordingly.
#+end_export
#+begin_src go <<Correct true positives, Pr. \ref{pr:cop}>>=
  n = 0
  accs = accessions["TruePositives"]
  for _, acc := range accs {
	  //<<Analyze true positive, Pr. \ref{pr:cop}>>
  }
  accessions["TruePositives"] = accs[:n]
#+end_src
#+begin_export latex
Depending on the distance to the reference, we classify the current
accession as either a true positive or a new false positive.
#+end_export
#+begin_src go <<Analyze true positive, Pr. \ref{pr:cop}>>=
  j := accMap[acc]
  di := mat.Matrix[ri][j]
  if di <= dt {
	  accs[n] = acc
	  n++
  } else {
	  nfp = append(nfp, acc)
  }
#+end_src
#+begin_export latex
We construct slices of true positives, false positives, and false
negative accessions. From the lengths of these slices we calculate the
sensitivity and the specificity of our primer set. That suffices for
printing the first three lines of our report, as shown in
Figure~\ref{fig:cops1}. Then we print the corrected accessions.
#+end_export
#+begin_src go <<Print corrected report, Pr. \ref{pr:cop}>>=
  //<<Construct slices of accessions, Pr. \ref{pr:cop}>>
  //<<Calculate sensitivity, Pr. \ref{pr:cop}>>
  //<<Calculate specificity, Pr. \ref{pr:cop}>>
  //<<Print first three lines of report, Pr. \ref{pr:cop}>>
  //<<Print accessions, Pr. \ref{pr:cop}>>
#+end_src
#+begin_export latex
We merge the approved true positives and the new positives into 
single slices. We also sort the accessions.
#+end_export
#+begin_src go <<Construct slices of accessions, Pr. \ref{pr:cop}>>=
  tps := accessions["TruePositives"]
  tps = append(tps, ntp...)
  sort.Strings(tps)
  fps := accessions["FalsePositives"]
  fps = append(fps, nfp...)
  sort.Strings(fps)
  fns := accessions["FalseNegatives"]
  sort.Strings(fns)
#+end_src
#+begin_export latex
We import \ty{sort}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "sort"
#+end_src
#+begin_export latex
Let $t_{\rm p}$ be the number of true positives and $f_{\rm n}$ the
number of false negatives, then the sensitivity is defined as the
fraction of taxa that should have been identified,
\[
s_{\rm n}=\frac{t_{\rm p}}{t_{\rm p}+f_{\rm n}}.
\]
#+end_export
#+begin_src go <<Calculate sensitivity, Pr. \ref{pr:cop}>>=
  tp := float64(len(tps))
  fn := float64(len(fns))
  sn := tp / (tp + fn)
#+end_src
#+begin_export latex
Let also $f_{\rm p}$ be the number of false positives, then the
specificity is defined as the fraction of true hits,
\[
s_{\rm p} = \frac{t_{\rm p}}{t_{\rm p}+f_{\rm p}}.
\]
#+end_export
#+begin_src go <<Calculate specificity, Pr. \ref{pr:cop}>>=
  fp := float64(len(fps))
  sp := tp / (tp + fp)
#+end_src
#+begin_export latex
The first three lines of the report consist of the primer set, the
sensitivity, and the specificity.
#+end_export
#+begin_src go <<Print first three lines of report, Pr. \ref{pr:cop}>>=
  fmt.Printf("PrimerSet:\t%s\n", primerSet)
  fmt.Printf("Sensitivity:\t%.3g\n", sn)
  fmt.Printf("Specificity:\t%.3g\n", sp)
#+end_src
#+begin_export latex
We import \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Pr. \ref{pr:cop}>>=
  "fmt"
#+end_src
#+begin_export latex
We print the accessions of the true positives, the false positives,
and the false negatives, in that order.
#+end_export
#+begin_src go <<Print accessions, Pr. \ref{pr:cop}>>=
  if len(tps) > 0 {
	  //<<Print true positives, Pr. \ref{pr:cop}>>
  }
  if len(fps) > 0 {
	  //<<Print false positives, Pr. \ref{pr:cop}>>
  }
  if len(fns) > 0 {
	  //<<Print false negatives, Pr. \ref{pr:cop}>>
  }
#+end_src
#+begin_export latex
We print the true positives either with distances or without. Both
cases are reused for the false positives and the false negatives, so
we delegate them to the functions \ty{printAcc} and \ty{printAccDist},
which we still need to write.
#+end_export
#+begin_src go <<Print true positives, Pr. \ref{pr:cop}>>=
  fmt.Print("TruePositives:\t")
  if pd && truePos {
	  printAccDist(tps, re, mat, accMap)
  } else {
	  printAcc(tps)
  }
#+end_src
#+begin_export latex
Inside \ty{printAccDist} we take some time to prepare the printing,
then print the first accession, followed by the rest.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:cop}>>=
  func printAccDist(accs []string, re string,
	  mat *dist.DistMat,
	  accMap map[string]int) {
	  //<<Prepare printing, Pr. \ref{pr:cop}>>
	  //<<Print first accession, Pr. \ref{pr:cop}>>
	  //<<Print remaining accessions, Pr. \ref{pr:cop}>>
  }
#+end_src
#+begin_export latex
By way of preparation, we isolate the distance matrix and the index of
the reference strain in that matrix.
#+end_export
#+begin_src go <<Prepare printing, Pr. \ref{pr:cop}>>=
  dists := mat.Matrix
  i := accMap[re]
#+end_src
#+begin_export latex
We print the first accession and distance delimited by a blank.
#+end_export
#+begin_src go <<Print first accession, Pr. \ref{pr:cop}>>=
  acc := accs[0]
  j := accMap[acc]
  d := dists[i][j]
  fmt.Printf("%s %.3g", acc, d)
#+end_src
#+begin_export latex
We iterate over the remaining accessions and print them together with
the distances, keeping to the blank-delimited format. We end the line
with a carriage return.
#+end_export
#+begin_src go <<Print remaining accessions, Pr. \ref{pr:cop}>>=
  accs = accs[1:]
  for _, acc := range accs {
	  j := accMap[acc]
	  d := dists[i][j]
	  fmt.Printf(" %s %.3g", acc, d)
  }
  fmt.Printf("\n")
#+end_src
#+begin_export latex
Printing just accessions is simpler, so inside \ty{printAcc} we print
the first accession without a leading blank and then the rest with.
#+end_export
#+begin_src go <<Functions, Pr. \ref{pr:cop}>>=
  func printAcc(accs []string) {
	  fmt.Printf("%s", accs[0])
	  accs = accs[1:]
	  for _, acc := range accs {
		  fmt.Printf(" %s", acc)
	  }
	  fmt.Printf("\n")
  }
#+end_src
#+begin_export latex
Using the functions \ty{printAcc} and \ty{printAccDist} we also print
the false positives.
#+end_export
#+begin_src go <<Print false positives, Pr. \ref{pr:cop}>>=
  fmt.Print("FalsePositives:\t")
  if pd {
	  printAccDist(fps, re, mat, accMap)
  } else {
	  printAcc(fps)
  }
#+end_src
#+begin_export latex
Finally, we print the false negatives.
#+end_export
#+begin_src go <<Print false negatives, Pr. \ref{pr:cop}>>=
  fmt.Print("FalseNegatives:\t")
  if pd {
	  printAccDist(fns, re, mat, accMap)
  } else {
	  printAcc(fns)
  }
#+end_src
#+begin_export latex
We have finished \ty{cops}, let's test it.
\section{Testing}
Our code for testing \ty{cops} contains hooks for imports and the
testing logic.
#+end_export
#+begin_src go <<cops_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Pr. \ref{pr:cop}>>
  )

  func TestCops(t *testing.T) {
	  //<<Testing, Pr. \ref{pr:cop}>>
  }
#+end_src
#+begin_export latex
We construct a set of tests and iterate over them.
#+end_export
#+begin_src go <<Testing, Pr. \ref{pr:cop}>>=
  var tests []*exec.Cmd
  //<<Construct tests, Pr. \ref{pr:cop}>>
  for i, test := range tests {
	  //<<Run test, Pr. \ref{pr:cop}>>
  }
#+end_src
#+begin_export latex
We import \ty{exec}.
#+end_export
#+begin_src go <<Testing imports, Pr. \ref{pr:cop}>>=
  "os/exec"
#+end_src
#+begin_export latex
Our tests run on the sample database, with reference strain EDL933,
which has accession AE005174, threshold distance 0.002, and input
\ty{scop.out}. The first test takes only default parameters. The
second test also returns the distances. The third and last test
returns distances and includes the true positives.
#+end_export
#+begin_src go <<Construct tests, Pr. \ref{pr:cop}>>=
  d := "../data/sample"
  r := "AE005174"
  x := "2e-3"
  i := "scop.out"
  test := exec.Command("./cops", "-d", d, "-r", r, "-t", x, i)
  tests = append(tests, test)
  test = exec.Command("./cops", "-d", d, "-r", r, "-t", x,
	  "-D", i)
  tests = append(tests, test)
  test = exec.Command("./cops", "-d", d, "-r", r, "-t", x,
	  "-D", "-p", i)
  tests = append(tests, test)
#+end_src
#+begin_export latex
When running a test, we compare the result we get with the result we
want, which is contained in files \ty{r1.txt}, \ty{r2.txt}, and
\ty{r3.txt}.
#+end_export
#+begin_src go <<Run test, Pr. \ref{pr:cop}>>=
  get, err := test.Output()
  if err != nil {
	  t.Error(err)
  }
  f := "r" + strconv.Itoa(i+1) + ".txt"
  want, err := os.ReadFile(f)
  if err != nil {
	  t.Error(err)
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_export latex
We import \ty{strconv}, \ty{os}, and \ty{bytes}.
#+end_export
#+begin_src go <<Testing imports, Pr. \ref{pr:cop}>>=
  "strconv"
  "os"
  "bytes"
#+end_src
