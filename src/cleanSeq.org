#+begin_src latex
  \section{Introduction}
  The marker candidates returned by \ty{fur} may contain long runs of
  \ty{N}. The program \ty{cleanSeq} cuts these runs from the results of
  \ty{fur} and ensures that the fragments produced are not too short.

  \section{Implementation}
  The outline of \ty{cleanSeq} has hooks for imports, types, variables,
  functions, and the logic of the main function.
    \begin{prog}[\texttt{cleanSeq}]\label{pr:cle}
      \textcolor{white}{}

#+end_src
#+begin_src go <<cleanSeq.go>>=
  package main

  import (
	  //<<Imports, Pr.~\ref{pr:cle}>>
  )
  //<<Variables, Pr.~\ref{pr:cle}>>
  //<<Types, Pr.~\ref{pr:cle}>>
  //<<Functions, Pr.~\ref{pr:cle}>>
  func main() {
	  //<<Main function, Pr.~\ref{pr:cle}>>
  }
#+end_src
#+begin_src latex
  \end{prog}
  In the main function we declare the options, set the usage, parse the
  options, and iterate over the input.
#+end_src
#+begin_src go <<Main function, Pr.~\ref{pr:cle}>>=
  //<<Declare options, Pr.~\ref{pr:cle}>>
  //<<Set usage, Pr.~\ref{pr:cle}>>
  //<<Parse options, Pr.~\ref{pr:cle}>>
  //<<Iterate over input, Pr.~\ref{pr:cle}>>
#+end_src
#+begin_src latex
  \ty{CleanSeq} requires a maximum run length and a minimum fragment
  length. The user can also use \ty{-v} to request the version.
#+end_src
#+begin_src go <<Declare options, Pr.~\ref{pr:cle}>>=
  var optL = flag.Int("l", 150, "maximum length of run of Ns")
  var optM = flag.Int("m", 100, "minimum fragment length")
  var optV = flag.Bool("v", false, "print version & " +
	  "program information")
#+end_src
#+begin_src latex
  We import \ty{flag}.
#+end_src
#+begin_src go <<Imports, Pr.~\ref{pr:cle}>>=
  "flag"
#+end_src
#+begin_src latex
  The usage consists of the usage message proper, an explanation of the
  program's purpose, and an example command.
#+end_src
#+begin_src go <<Set usage, Pr.~\ref{pr:cle}>>=
  u := "cleanSeq [-h] [option]... [file]..."
  p := "Clean the sequences returned by fur."
  e := "cleanSeq foo.fasta"
  clio.Usage(u, p, e);
#+end_src
#+begin_src latex
  We import \ty{clio}.
#+end_src
#+begin_src go <<Imports, Pr.~\ref{pr:cle}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  We parse the options and respond to \ty{-v}.
#+end_src
#+begin_src go <<Parse options, Pr.~\ref{pr:cle}>>=
  flag.Parse()
  if *optV {
	  a := "Bernhard Haubold"
	  e := "haubold@evolbio.mpg.de"
	  l := "GNU General Public License, " +
		  "https://www.gnu.org/licenses/gpl.html"
	  clio.PrintInfo("cleanSeq", version, date, a, e, l)
	  os.Exit(0)
  }
#+end_src
#+begin_src latex
  The variables \ty{version} and \ty{date} get injected at compile time.
#+end_src
#+begin_src go <<Variables, Pr.~\ref{pr:cle}>>=
  var version, date string
#+end_src
#+begin_src latex
  We import \ty{os}.
#+end_src
#+begin_src go <<Imports, Pr.~\ref{pr:cle}>>=
  "os"
#+end_src
#+begin_src latex
  We iterate over the input by calling \ty{clio.PaseFiles} on the input
  files. This takes as argument the function \ty{parse}, which in turn
  takes as arguments the parameters of the cleaning procedure.
#+end_src
#+begin_src go <<Iterate over input, Pr.~\ref{pr:cle}>>=
  files := flag.Args()
  clio.ParseFiles(files, parse, *optL, *optM)
#+end_src
#+begin_src latex
  In \ty{parse} we retrieve the arguments just passed and iterate over
  the sequences in the input file, which are cleaned and the resulting
  fragments printed.
#+end_src
#+begin_src go <<Functions, Pr.~\ref{pr:cle}>>=
  func parse(r io.Reader, args ...interface{}) {
	  //<<Retrieve arguments, Pr.~\ref{pr:cle}>>
	  scanner := fasta.NewScanner(r)
	  for scanner.ScanSequence() {
		  sequence := scanner.Sequence()
		  header := sequence.Header()
		  data := sequence.Data()
		  //<<Clean sequence, Pr.~\ref{pr:cle}>>
		  //<<Print fragments, Pr.~\ref{pr:cle}>>
	  }
  }
#+end_src
#+begin_src latex
  We import \ty{io} and \ty{fasta}.
#+end_src
#+begin_src go <<Imports, Pr.~\ref{pr:cle}>>=
  "io"
  "github.com/evolbioinf/fasta"
#+end_src
#+begin_src latex
  We retrieve the two arguments just passed through type assertion.
#+end_src
#+begin_src go <<Retrieve arguments, Pr.~\ref{pr:cle}>>=
  maxRunLen := args[0].(int)
  minFragLen := args[1].(int)
#+end_src
#+begin_src latex
  We clean a sequence by first identifying its long runs of \ty{N}. Then
  remove them and any short fragments thus produced.
#+end_src
#+begin_src go <<Clean sequence, Pr.~\ref{pr:cle}>>=
  //<<Identify long runs of \ty{N}, Pr.~\ref{pr:cle}>>
  //<<Remove long runs of \ty{N}, Pr.~\ref{pr:cle}>>
  //<<Remove short fragments, Pr.~\ref{pr:cle}>>
#+end_src
#+begin_src latex
  We use a slice of intervals to store the start and end positions of
  runs runs that are either prefixex, suffixes, or have the minimum
  number of \ty{N}s.
#+end_src
#+begin_src go <<Identify long runs of \ty{N}, Pr.~\ref{pr:cle}>>=
  var runs []interval
  var run interval
  for i := 0; i < len(data); i++ {
	  j := 0
	  for i+j < len(data) && data[i+j] == 'N' { j++ }
	  if (i == 0 && j > 0) || i + j == len(data) || j >= maxRunLen {
		  run.start = i
		  run.end = i + j - 1
		  runs = append(runs, run)
	  }
	  i += j
  }
#+end_src
#+begin_src latex
  We declare an \ty{interval} with a \ty{start} and an \ty{end}.
#+end_src
#+begin_src go <<Types, Pr.~\ref{pr:cle}>>=
  type interval struct {
	  start, end int
  }
#+end_src
#+begin_src latex
  If our sequence contains one or more long runs of \ty{N}s, it is split
  into the corresponding fragments.
#+end_src
#+begin_src go <<Remove long runs of \ty{N}, Pr.~\ref{pr:cle}>>=
  var fragments []*fasta.Sequence
  prevEnd := 0
  for _, run = range runs {
	  seq := fasta.NewSequence(header,
		  data[prevEnd:run.start])
	  fragments = append(fragments, seq)
	  prevEnd = run.end
  }
  if len(runs) > 0 && run.end < len(data) {
	  seq := fasta.NewSequence(header, data[run.end+1:])
	  fragments = append(fragments, seq)
  }
#+end_src
#+begin_src latex
  If there weren't any runs, there is only one fragment, the original
  sequence.
#+end_src
#+begin_src go <<Remove long runs of \ty{N}, Pr.~\ref{pr:cle}>>=
  if len(runs) == 0 {
	  fragments = append(fragments, sequence)
  }
#+end_src
#+begin_src latex
  We squeeze short fragments out of the slice.
#+end_src
#+begin_src go <<Remove short fragments, Pr.~\ref{pr:cle}>>=
  i := 0
  for _, f := range fragments {
	  if len(f.Data()) >= minFragLen {
		  fragments[i] = f
		  i++
	  }
  }
  fragments = fragments[0:i]
#+end_src
#+begin_src latex
  Any fragments produced at this stage have the same header. If there
  are more than one, this is confusing. So in that case we number the
  headers.
#+end_src
#+begin_src go <<Remove short fragments, Pr.~\ref{pr:cle}>>=
  if len(fragments) > 1 {
	  for i, f := range fragments {
		  f.AppendToHeader(" - F" + strconv.Itoa(i+1))
	  }
  }
#+end_src
#+begin_src latex 
  We import \ty{strconv}.
#+end_src
#+begin_src go <<Imports, Pr.~\ref{pr:cle}>>=
  "strconv"
#+end_src
#+begin_src latex
  We print the fragments using the print mechanism for sequences.
#+end_src
#+begin_src go <<Print fragments, Pr.~\ref{pr:cle}>>=
  for _, f := range fragments {
	  fmt.Println(f)
  }
#+end_src
#+begin_src latex
  We import \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Pr.~\ref{pr:cle}>>=
  "fmt"
#+end_src



